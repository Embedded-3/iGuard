/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title MULTICAN data transmission
 * \abstract MULTICAN is used to exchange data between two nodes, implemented in the same device using Loop-Back mode.
 * \description A CAN message is sent from CAN node 0 to CAN node 1 using Loop-Back mode.
 *              After the CAN message transmission, an interrupt will be generated and LED1 will
 *              be turned on to confirm successful message transmission. Once the CAN message
 *              is successfully received by the CAN node 1, an interrupt will be generated.
 *              Inside the interrupt service routine the content of the received CAN message will be
 *              compared to the content of the transmitted CAN message. In case of a success, LED2
 *              will be turned on to confirm successful message reception.
 *
 * \name MULTICAN_1_KIT_TC275_LK
 * \version V1.0.0
 * \board AURIX TC275 lite Kit, KIT_AURIX_TC275_LITE, TC27xTP_D-Step
 * \keywords AURIX, CAN, MULTICAN, MULTICAN_1
 * \documents https://www.infineon.com/aurix-expert-training/Infineon-AURIX_MULTICAN_1_KIT_TC275_LK-TR-v01_00_00-EN.pdf
 * \documents https://www.infineon.com/aurix-expert-training/TC27D_iLLD_UM_1_0_1_12_0.chm
 * \lastUpdated 2021-06-29
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxStm.h"
//#include "MULTICAN.h"
#include "IfxMultican_Can.h"
#include "asclin_driver/asclin.h"

/* 글로벌 핸들 */
IfxMultican_Can        g_can;         // CAN 모듈 핸들
IfxMultican_Can_Node   g_canNode;     // CAN 노드 핸들
IfxMultican_Can_MsgObj g_txMsgObj;    // 송신 메시지 오브젝트
IfxMultican_Can_MsgObj g_rxMsgObj;    // 수신 메시지 오브젝트

/* 송신 메시지 */
IfxMultican_Message g_txMsg;
/* 수신 메시지 */
IfxMultican_Message g_rxMsg;

/* 초기화 함수 */
void initCan(void)
{
    /* 1. CAN 모듈 초기화 */
    IfxMultican_Can_Config canConfig;
    IfxMultican_Can_initModuleConfig(&canConfig, &MODULE_CAN);
    IfxMultican_Can_initModule(&g_can, &canConfig);

    /* 2. CAN 노드 초기화 */
    IfxMultican_Can_NodeConfig nodeConfig;
    IfxMultican_Can_Node_initConfig(&nodeConfig, &g_can);

    nodeConfig.nodeId = IfxMultican_NodeId_0;  // Node0 사용
    nodeConfig.baudrate = 250000;              // 250kbps 설정
    nodeConfig.samplePoint = 8000;             // 샘플 포인트 80%
    nodeConfig.rxPin = &IfxMultican_RXD0B_P20_7_IN;  // RX 핀 (P20.7)
    nodeConfig.txPin = &IfxMultican_TXD0_P20_8_OUT;  // TX 핀 (P20.8)
    nodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
    nodeConfig.txPinMode = IfxPort_OutputMode_pushPull;
    nodeConfig.pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1; // 패드 드라이버 설정

    IfxMultican_Can_Node_init(&g_canNode, &nodeConfig);

    /* 3. 송신 메시지 오브젝트 초기화 */
    IfxMultican_Can_MsgObjConfig txMsgConfig;
    IfxMultican_Can_MsgObj_initConfig(&txMsgConfig, &g_canNode);

    txMsgConfig.msgObjId = 0;  // 오브젝트 ID 0
    txMsgConfig.messageId = 0x100;  // 송신 ID: 0x100
    txMsgConfig.frame = IfxMultican_Frame_transmit;
    txMsgConfig.control.messageLen = IfxMultican_DataLengthCode_8;

    IfxMultican_Can_MsgObj_init(&g_txMsgObj, &txMsgConfig);

    /* 4. 수신 메시지 오브젝트 초기화 */
    IfxMultican_Can_MsgObjConfig rxMsgConfig;
    IfxMultican_Can_MsgObj_initConfig(&rxMsgConfig, &g_canNode);

    rxMsgConfig.msgObjId = 1;  // 오브젝트 ID 1
    rxMsgConfig.messageId = 0x200;  // 수신 ID: 0x200
    rxMsgConfig.frame = IfxMultican_Frame_receive;
    rxMsgConfig.control.messageLen = IfxMultican_DataLengthCode_8;

    IfxMultican_Can_MsgObj_init(&g_rxMsgObj, &rxMsgConfig);

    /* 송신 메시지 데이터 준비 */
    IfxMultican_Message_init(&g_txMsg, 0x100, 0x11223344, 0x55667788, 8);  // ID 0x100, 데이터 8 bytes
}

/* 송신 함수 */
void sendCanMessage(void)
{
    IfxMultican_Can_MsgObj_sendMessage(&g_txMsgObj, &g_txMsg);
}

/* 수신 대기 및 출력 함수 */
void canReceiveLoop(void)
{
    while (1)
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(g_rxMsgObj.node->mcan, g_rxMsgObj.msgObjId);

        // 메시지가 수신되었는지 확인
        if (IfxMultican_MsgObj_isRxPending(hwObj))
        {
            // 수신 메시지 읽기
            IfxMultican_Message_init(&g_rxMsg, 0, 0, 0, 8);  // ID, data 초기화
            IfxMultican_Status status = IfxMultican_MsgObj_readMessage(hwObj, &g_rxMsg);

            // 수신 성공
            if (status & IfxMultican_Status_newData)
            {
                print("[CAN 수신 성공]\n");
                print("ID: 0x%03X\n", g_rxMsg.id);
                print("Data[0]: 0x%08X\n", g_rxMsg.data[0]);
                print("Data[1]: 0x%08X\n", g_rxMsg.data[1]);
            }

            // 수신 Pending Clear
            IfxMultican_MsgObj_clearRxPending(hwObj);
        }

        // 잠깐 쉬어 CPU 낭비 방지 (약 1ms 대기)
        IfxStm_wait(10000000);
    }
}

IfxCpu_syncEvent g_cpuSyncEvent = 0;

int core0_main(void)
{
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    /* Application code: initialization of MULTICAN, LEDs and the transmission of the CAN message */
//    initMultican();
//    initLed();
    initCan();
    initShellInterface();
    //transmitCanMessage();
    while(1)
    {
        sendCanMessage();
        IfxStm_wait(100000);
        canReceiveLoop();
    }
    return (1);
}
